<script>
(function(global) {
    function initBookingEditForm(container, options) {
        if (!container) {
            return;
        }

        const form = container.querySelector('form.booking-edit-form');
        if (!form || form.dataset.initialized === 'true') {
            return;
        }

        form.dataset.initialized = 'true';

        const bookingId = form.dataset.bookingId;
        const validateUrl = form.dataset.validateUrl;
        const availableCabinetsUrl = form.dataset.availableCabinetsUrl;
        const specialistsUrl = form.dataset.specialistsUrl;
        const csrfInput = form.querySelector('[name=csrfmiddlewaretoken]');
        const csrfToken = csrfInput ? csrfInput.value : '';
        const validationMessage = form.querySelector('[data-role="validation-message"]');
        const startDatetimeValidation = form.querySelector('[data-role="start-validation"]');
        const cabinetHelpText = form.querySelector('[data-role="cabinet-help"]');
        const cabinetHelpDefault = cabinetHelpText ? (cabinetHelpText.dataset.defaultText || cabinetHelpText.textContent) : '';

        const serviceVariantSelect = form.querySelector('#id_service_variant');
        const specialistSelect = form.querySelector('#id_specialist');
        const startDatetimeInput = form.querySelector('#id_start_datetime');
        const cabinetSelect = form.querySelector('#id_cabinet');
        const recurrenceToggle = form.querySelector('#id_recurrence_enabled');
        const recurrenceSettings = form.querySelector('[data-role=\"recurrence-settings\"]');
        const recurrenceFrequency = form.querySelector('#id_recurrence_frequency');
        const recurrenceIntervalLabel = form.querySelector('[data-role=\"recurrence-interval-label\"]');
        const recurrenceWeekdaysBlock = form.querySelector('[data-role=\"recurrence-weekdays\"]');
        const recurrenceEndType = form.querySelector('#id_recurrence_end_type');
        const recurrenceCountField = form.querySelector('[data-role=\"recurrence-count-field\"]');
        const recurrenceUntilField = form.querySelector('[data-role=\"recurrence-until-field\"]');
        const recurrenceExcludedDisplay = form.querySelector('[data-role=\"recurrence-excluded-display\"]');
        const recurrenceExcludedHidden = form.querySelector('#id_recurrence_excluded_dates');

        if (!serviceVariantSelect || !specialistSelect || !startDatetimeInput || !cabinetSelect) {
            return;
        }

        let validationTimeout = null;
        let startPicker = null;

        if (window.flatpickr && startDatetimeInput) {
            if (startDatetimeInput._flatpickr) {
                startDatetimeInput._flatpickr.destroy();
            }
            const localeConfig = window.flatpickr.l10ns && window.flatpickr.l10ns.ru ? window.flatpickr.l10ns.ru : 'ru';
            startPicker = window.flatpickr(startDatetimeInput, {
                enableTime: true,
                time_24hr: true,
                dateFormat: 'Y-m-d\\TH:i',
                altInput: true,
                altFormat: 'd.m.Y, H:i',
                allowInput: true,
                minuteIncrement: 5,
                locale: localeConfig,
                onChange: function() {
                    loadAvailableCabinets();
                    scheduleValidation();
                }
            });
        }

        function setCabinetHelp(message, type) {
            if (!cabinetHelpText) return;
            cabinetHelpText.textContent = message;
            cabinetHelpText.classList.remove('text-muted', 'text-primary', 'text-danger');
            if (type === 'loading') {
                cabinetHelpText.classList.add('text-primary');
            } else if (type === 'error') {
                cabinetHelpText.classList.add('text-danger');
            } else {
                cabinetHelpText.classList.add('text-muted');
            }
        }

        function loadAvailableCabinets() {
            const serviceVariantId = serviceVariantSelect.value;
            const specialistId = specialistSelect.value;
            const startDatetime = startDatetimeInput.value;

            if (!serviceVariantId || !specialistId || !startDatetime) {
                cabinetSelect.innerHTML = '<option value="">Сначала выберите услугу, специалиста и время</option>';
                setCabinetHelp(cabinetHelpDefault, 'muted');
                return;
            }

            const currentCabinet = cabinetSelect.value;
            const selectedOption = cabinetSelect.options[cabinetSelect.selectedIndex];
            const previousLabel = selectedOption ? selectedOption.textContent.trim() : '';

            cabinetSelect.innerHTML = '';
            const loadingOption = document.createElement('option');
            loadingOption.value = currentCabinet || '';
            loadingOption.selected = true;
            loadingOption.textContent = previousLabel ? `${previousLabel} (обновляем...)` : 'Загрузка доступных кабинетов...';
            cabinetSelect.appendChild(loadingOption);
            cabinetSelect.disabled = true;
            setCabinetHelp('Обновляем список кабинетов...', 'loading');

            const params = new URLSearchParams({
                service_variant_id: serviceVariantId,
                specialist_id: specialistId,
                datetime: startDatetime
            });

            if (bookingId) {
                params.append('exclude_booking_id', bookingId);
            }

            fetch(`${availableCabinetsUrl}?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    cabinetSelect.disabled = false;
                    if (data.error) {
                        cabinetSelect.innerHTML = `<option value="">${data.error}</option>`;
                        setCabinetHelp(data.error, 'error');
                        return;
                    }

                    cabinetSelect.innerHTML = '<option value="">-- Выберите кабинет --</option>';
                    if (Array.isArray(data.cabinets) && data.cabinets.length) {
                        let cabinetFound = false;
                        data.cabinets.forEach(cabinet => {
                            const option = document.createElement('option');
                            option.value = cabinet.id;
                            option.textContent = cabinet.name;
                            if (String(cabinet.id) === String(currentCabinet)) {
                                option.selected = true;
                                cabinetFound = true;
                            }
                            cabinetSelect.appendChild(option);
                        });
                        if (!cabinetFound && currentCabinet) {
                            console.warn('Current cabinet not found in available cabinets');
                        }
                        setCabinetHelp(cabinetHelpDefault, 'muted');
                    } else if (currentCabinet) {
                        cabinetSelect.innerHTML = `<option value="${currentCabinet}" selected>Текущий кабинет (может быть недоступен)</option>`;
                        setCabinetHelp('Текущий кабинет может быть недоступен для выбранного времени', 'error');
                    } else {
                        cabinetSelect.innerHTML = '<option value="">Нет доступных кабинетов</option>';
                        setCabinetHelp('Свободные кабинеты не найдены для выбранного времени', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error loading cabinets:', error);
                    cabinetSelect.disabled = false;
                    cabinetSelect.innerHTML = '<option value="">Ошибка загрузки</option>';
                    setCabinetHelp('Не удалось загрузить кабинеты. Попробуйте позже.', 'error');
                });
        }

        function validateBookingEdit() {
            if (!validateUrl) {
                return;
            }

            const serviceVariantId = serviceVariantSelect.value;
            const specialistId = specialistSelect.value;
            const startDatetime = startDatetimeInput.value;
            const cabinetId = cabinetSelect.value;

            if (!serviceVariantId || !specialistId || !startDatetime || !cabinetId) {
                if (validationMessage) {
                    validationMessage.classList.add('d-none');
                }
                if (startDatetimeValidation) {
                    startDatetimeValidation.innerHTML = '';
                }
                return;
            }

            const formData = new FormData();
            formData.append('start_datetime', startDatetime);
            formData.append('service_variant', serviceVariantId);
            formData.append('specialist', specialistId);
            formData.append('cabinet', cabinetId);
            if (csrfToken) {
                formData.append('csrfmiddlewaretoken', csrfToken);
            }

            fetch(validateUrl, {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (!validationMessage || !startDatetimeValidation) {
                        return;
                    }
                    if (data.valid) {
                        // Показываем предупреждение если есть конфликты, но не блокируем
                        if (data.warning) {
                            validationMessage.classList.remove('alert-success', 'd-none');
                            validationMessage.classList.add('alert-warning');
                            validationMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> <strong>Внимание:</strong> ${data.warning}`;
                            startDatetimeValidation.innerHTML = `<small class="text-warning"><i class="bi bi-exclamation-triangle"></i> ${data.warning}</small>`;
                        } else {
                            validationMessage.classList.remove('alert-danger', 'alert-warning');
                            validationMessage.classList.add('alert-success', 'd-none');
                            validationMessage.textContent = '';
                            startDatetimeValidation.innerHTML = '<small class="text-success"><i class="bi bi-check-circle"></i> Время доступно</small>';
                        }
                    } else {
                        validationMessage.classList.remove('alert-success', 'alert-warning', 'd-none');
                        validationMessage.classList.add('alert-danger');
                        validationMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${data.error || 'Ошибка валидации'}`;
                        startDatetimeValidation.innerHTML = `<small class="text-danger"><i class="bi bi-x-circle"></i> ${data.error || 'Ошибка'}</small>`;
                    }
                })
                .catch(error => {
                    console.error('Error validating booking:', error);
                    if (!validationMessage) return;
                    validationMessage.classList.remove('alert-success', 'd-none');
                    validationMessage.classList.add('alert-danger');
                    validationMessage.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Ошибка при проверке данных';
                });
        }

        function loadSpecialistsForService() {
            const serviceVariantId = serviceVariantSelect.value;
            const currentSpecialist = specialistSelect.value;

            if (!serviceVariantId) {
                specialistSelect.innerHTML = '<option value="">Сначала выберите услугу</option>';
                return;
            }

            specialistSelect.innerHTML = '<option value="">Загрузка...</option>';
            specialistSelect.disabled = true;

            const specialistUrl = `${specialistsUrl}?service_variant_id=${serviceVariantId}`;

            fetch(specialistUrl)
                .then(response => response.json())
                .then(data => {
                    specialistSelect.disabled = false;
                    specialistSelect.innerHTML = '<option value="">Выберите специалиста</option>';
                    data.forEach(specialist => {
                        const option = document.createElement('option');
                        option.value = specialist.id;
                        option.textContent = specialist.full_name;
                        if (String(specialist.id) === String(currentSpecialist)) {
                            option.selected = true;
                        }
                        specialistSelect.appendChild(option);
                    });

                    if (!startDatetimeInput.value || String(specialistSelect.value) !== String(currentSpecialist)) {
                        cabinetSelect.innerHTML = '<option value="">Сначала выберите специалиста и время</option>';
                    } else {
                        loadAvailableCabinets();
                    }
                })
                .catch(error => {
                    console.error('Error loading specialists:', error);
                    specialistSelect.disabled = false;
                    specialistSelect.innerHTML = '<option value="">Ошибка загрузки</option>';
                });
        }

        function scheduleValidation() {
            if (validationTimeout) {
                clearTimeout(validationTimeout);
            }
            validationTimeout = setTimeout(validateBookingEdit, 500);
        }

        serviceVariantSelect.addEventListener('change', function() {
            loadSpecialistsForService();
            loadAvailableCabinets();
            scheduleValidation();
        });

        specialistSelect.addEventListener('change', function() {
            loadAvailableCabinets();
            scheduleValidation();
        });

        startDatetimeInput.addEventListener('change', function() {
            loadAvailableCabinets();
            scheduleValidation();
        });
        startDatetimeInput.addEventListener('input', scheduleValidation);

        cabinetSelect.addEventListener('change', scheduleValidation);

        function toggleRecurrenceSettingsState(forceEnabled) {
            if (!recurrenceSettings) return;
            const enabled = typeof forceEnabled === 'boolean'
                ? forceEnabled
                : (recurrenceToggle ? recurrenceToggle.checked : false);
            recurrenceSettings.classList.toggle('d-none', !enabled);
            if (recurrenceToggle) {
                recurrenceToggle.checked = enabled;
            }
            if (!enabled && recurrenceExcludedHidden) {
                recurrenceExcludedHidden.value = '';
                if (recurrenceExcludedDisplay) {
                    recurrenceExcludedDisplay.value = '';
                }
            }
        }

        function updateRecurrenceIntervalLabel() {
            if (!recurrenceIntervalLabel || !recurrenceFrequency) return;
            const freq = recurrenceFrequency.value;
            let suffix = '';
            switch (freq) {
                case 'weekly':
                    suffix = 'недель';
                    break;
                case 'monthly':
                    suffix = 'месяцев';
                    break;
                case 'yearly':
                    suffix = 'лет';
                    break;
                default:
                    suffix = 'дней';
            }
            recurrenceIntervalLabel.textContent = suffix;
        }

        function updateRecurrenceFrequencyState() {
            updateRecurrenceIntervalLabel();
            if (!recurrenceWeekdaysBlock) return;
            if (recurrenceFrequency && recurrenceFrequency.value === 'weekly') {
                recurrenceWeekdaysBlock.classList.remove('d-none');
            } else {
                recurrenceWeekdaysBlock.classList.add('d-none');
            }
        }

        function updateRecurrenceEndState() {
            if (!recurrenceEndType) return;
            const value = recurrenceEndType.value || 'count';
            if (recurrenceCountField) {
                recurrenceCountField.classList.toggle('d-none', value !== 'count');
            }
            if (recurrenceUntilField) {
                recurrenceUntilField.classList.toggle('d-none', value !== 'until');
            }
        }

        function hydrateExcludedDisplay() {
            if (!recurrenceExcludedHidden || !recurrenceExcludedDisplay) return;
            const raw = recurrenceExcludedHidden.value;
            if (!raw) {
                recurrenceExcludedDisplay.value = '';
                return;
            }
            try {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) {
                    const formatted = parsed.map((iso) => {
                        if (typeof iso !== 'string') return null;
                        const parts = iso.split('-');
                        if (parts.length !== 3) return null;
                        return `${parts[2]}.${parts[1]}.${parts[0]}`;
                    }).filter(Boolean);
                    recurrenceExcludedDisplay.value = formatted.join(', ');
                    return;
                }
            } catch (err) {
                console.warn('Cannot parse recurrence excluded dates', err);
            }
            recurrenceExcludedDisplay.value = raw;
        }

        function syncExcludedDates() {
            if (!recurrenceExcludedHidden || !recurrenceExcludedDisplay) return;
            const raw = recurrenceExcludedDisplay.value.trim();
            if (!raw) {
                recurrenceExcludedHidden.value = '';
                return;
            }
            const parts = raw.split(',').map((item) => item.trim()).filter(Boolean);
            const isoDates = [];
            parts.forEach((item) => {
                if (!item) return;
                let normalized = item.replace(/\//g, '.');
                const isoMatch = normalized.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                if (isoMatch) {
                    isoDates.push(`${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`);
                    return;
                }
                const match = normalized.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
                if (match) {
                    const day = match[1].padStart(2, '0');
                    const month = match[2].padStart(2, '0');
                    const year = match[3];
                    isoDates.push(`${year}-${month}-${day}`);
                }
            });
            recurrenceExcludedHidden.value = isoDates.length ? JSON.stringify(isoDates) : '';
        }

        if (recurrenceToggle) {
            recurrenceToggle.addEventListener('change', function() {
                toggleRecurrenceSettingsState();
            });
        }

        if (recurrenceFrequency) {
            recurrenceFrequency.addEventListener('change', function() {
                updateRecurrenceFrequencyState();
            });
        }

        if (recurrenceEndType) {
            recurrenceEndType.addEventListener('change', function() {
                updateRecurrenceEndState();
            });
        }

        if (recurrenceExcludedDisplay) {
            recurrenceExcludedDisplay.addEventListener('blur', syncExcludedDates);
        }

        toggleRecurrenceSettingsState(recurrenceToggle ? recurrenceToggle.checked : false);
        updateRecurrenceFrequencyState();
        updateRecurrenceEndState();
        hydrateExcludedDisplay();

        if (serviceVariantSelect.value) {
            const initialCabinetValue = cabinetSelect.value;
            loadSpecialistsForService();
            if (serviceVariantSelect.value && specialistSelect.value && startDatetimeInput.value) {
                setTimeout(function() {
                    loadAvailableCabinets();
                    if (initialCabinetValue) {
                        setTimeout(function() {
                            cabinetSelect.value = initialCabinetValue;
                        }, 100);
                    }
                }, 500);
            }
        }

        form.addEventListener('submit', function() {
            syncExcludedDates();
        }, { capture: true });

        // Загрузка логов бронирования
        const logsCard = container.querySelector('[data-role="booking-logs-card"]');
        const logsBody = container.querySelector('[data-role="booking-logs-body"]');
        const refreshLogsBtn = container.querySelector('[data-role="refresh-logs"]');
        const logsUrl = form.dataset.logsUrl;
        const logsCollapse = container.querySelector('#bookingLogsCollapse');

        function loadBookingLogs() {
            if (!logsUrl || !logsBody) return;

            logsBody.innerHTML = `
                <div class="text-center py-3">
                    <div class="spinner-border spinner-border-sm text-info" role="status">
                        <span class="visually-hidden">Загрузка...</span>
                    </div>
                    <p class="text-muted small mt-2 mb-0">Загрузка истории...</p>
                </div>
            `;

            fetch(logsUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.logs) {
                        renderLogs(data.logs);
                    } else {
                        logsBody.innerHTML = '<p class="text-muted text-center py-3">История изменений недоступна</p>';
                    }
                })
                .catch(error => {
                    console.error('Error loading booking logs:', error);
                    logsBody.innerHTML = '<p class="text-danger text-center py-3">Ошибка загрузки истории</p>';
                });
        }
        
        // Автоматически раскрываем логи при первой загрузке (опционально)
        // Можно раскомментировать, если нужно автоматически раскрывать
        // if (logsCollapse) {
        //     const bsCollapse = new bootstrap.Collapse(logsCollapse, { toggle: false });
        //     bsCollapse.show();
        // }

        function renderLogs(logs) {
            if (!logs || logs.length === 0) {
                logsBody.innerHTML = '<p class="text-muted text-center py-3">История изменений пуста</p>';
                return;
            }

            const actionIcons = {
                'created': 'bi-plus-circle text-success',
                'updated': 'bi-pencil text-primary',
                'deleted': 'bi-trash text-danger',
                'status_changed': 'bi-flag text-warning',
                'time_changed': 'bi-clock text-info',
                'specialist_changed': 'bi-person text-primary',
                'cabinet_changed': 'bi-door-open text-primary',
                'service_changed': 'bi-briefcase text-primary',
                'series_created': 'bi-arrow-repeat text-success',
                'series_updated': 'bi-arrow-repeat text-primary',
                'duplicated': 'bi-files text-info'
            };

            const actionColors = {
                'created': 'success',
                'updated': 'primary',
                'deleted': 'danger',
                'status_changed': 'warning',
                'time_changed': 'info',
                'specialist_changed': 'primary',
                'cabinet_changed': 'primary',
                'service_changed': 'primary',
                'series_created': 'success',
                'series_updated': 'primary',
                'duplicated': 'info'
            };

            let html = '<div class="list-group list-group-flush">';
            logs.forEach(log => {
                const iconClass = actionIcons[log.action] || 'bi-circle text-secondary';
                const badgeColor = actionColors[log.action] || 'secondary';
                
                html += `
                    <div class="list-group-item px-0 py-2 border-0 border-bottom">
                        <div class="d-flex align-items-start">
                            <div class="flex-shrink-0 me-2">
                                <i class="bi ${iconClass} fs-5"></i>
                            </div>
                            <div class="flex-grow-1">
                                <div class="d-flex justify-content-between align-items-start mb-1">
                                    <div>
                                        <span class="badge bg-${badgeColor} me-2">${log.action_display}</span>
                                        <span class="text-muted small">${log.created_at}</span>
                                    </div>
                                </div>
                                <p class="mb-1 small">${escapeHtml(log.message)}</p>
                                <div class="d-flex justify-content-between align-items-center">
                                    <span class="text-muted small">
                                        <i class="bi bi-person"></i> ${escapeHtml(log.user_full_name || log.user)}
                                    </span>
                                    ${log.ip_address ? `<span class="text-muted small"><i class="bi bi-globe"></i> ${escapeHtml(log.ip_address)}</span>` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            logsBody.innerHTML = html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        if (logsUrl && logsBody) {
            // Загружаем логи только при раскрытии аккордеона
            if (logsCollapse) {
                logsCollapse.addEventListener('show.bs.collapse', function() {
                    if (logsBody.querySelector('.spinner-border')) {
                        loadBookingLogs();
                    }
                });
            } else {
                // Если аккордеон не найден, загружаем сразу (fallback)
                loadBookingLogs();
            }
        }

        if (refreshLogsBtn) {
            refreshLogsBtn.addEventListener('click', function(e) {
                e.stopPropagation(); // Предотвращаем закрытие аккордеона
                loadBookingLogs();
            });
        }

        // Автоматически загружаем кабинеты при инициализации, если все поля заполнены
        if (serviceVariantSelect.value && specialistSelect.value && startDatetimeInput.value) {
            // Небольшая задержка, чтобы убедиться, что все элементы готовы
            setTimeout(function() {
                loadAvailableCabinets();
            }, 100);
        }

        if (options && typeof options.onInit === 'function') {
            options.onInit(form);
        }
    }

    global.initBookingEditForm = initBookingEditForm;
})(window);
</script>
